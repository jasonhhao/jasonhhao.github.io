---
layout: post
title:  LBP feature
date:   2018-12-09 00:00:00 +0800
categories: 计算机视觉
tag: LBP特征
---

* content
{:toc}


### 宏观理解
我们处理图片多了，就会发现其实计算机看图片就是通过当前像素点和旁边像素点的差异，就比如之前讲的HOG特征，就是找出像素点之前的梯度变化。万变不离其宗，LBP特征也是根据一个像素点和其他像素点的比较来锁定物体位置。

### 微观分析
这个理解起来比HOG要简单很多。我们把一个block定义在一个3*3的像素网格内，然后计算中心的像素点与其周围8个像素点的差异，如果大于中心点，标记为1，小于则标记为0。所以大概结果是这样的：

<p align="center"> 
  <img src="/imgs/lbpfeature/1.png">
</p>

然后我们就得到来LBP编码：11010011 。

除了这样的3*3网格为一个LBP算子，还有圆形的算子，并且大小任意：

<p align="center"> 
  <img src="/imgs/lbpfeature/2.png">
</p>

但是细心的同学会发现一个问题，我们的LBP编码，不是唯一的啊，这要看你读的起点在哪里，11010011可以，11110100就不可以吗？既然可以的话那不就会产生很大变化？

对的。这确实是LBP特征存在的问题，为了解决这个问题，Maenpaa等人将其进行了拓展，保证了一个像素点仅有唯一的编码。方法实在简单，就是在旋转的过程中我们可以得到8组变换，那么我们就规定好，我们只要这8组二进制编码中最小的那个。。（就是这么随性）

<p align="center"> 
  <img src="/imgs/lbpfeature/3.png">
</p>

所以像上图一样，无论怎么旋转，最终输出的都是最小的二进制编码。

好了，现在我们把所有的像素点的LBP编码都求出来之后他们又可以组成一个图片，叫做LBP图谱：

<p align="center"> 
  <img src="/imgs/lbpfeature/4.png">
</p>

但是我们并不能用图谱来进行分类，我们还是需要转化成直方图的形式。但是问题是，如果我们按照上面的程序做下来我们只能得到一个直方图。这个对于描述一个图片的信息显然是不够的。

那么我们可以把一张图片分成n等份，每一份去做一个直方图出来，最后我们就有n个直方图。

<p align="center"> 
  <img src="/imgs/lbpfeature/5.png">
</p>

最后我们把直方图归一化并且把所有的直方图进行拼接，就得到了这一张照片的LBP纹理特征向量，最后用它去做分类就好。
